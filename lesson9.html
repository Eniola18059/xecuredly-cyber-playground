<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lesson 9 — DoS / DDoS & Session Hijacking (Expanded + TTS + 10-question Quiz)</title>
<style>
  :root{
    --bg:#071428; --card:#0f2136; --muted:#9db7d9; --text:#e9f6ff;
    --accent:#57a7ff; --accent2:#7ef0c8; --danger:#ff7a7a; --ok:#9ef0b2;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{background:linear-gradient(135deg,var(--bg) 0%, #031427 100%);color:var(--text);-webkit-font-smoothing:antialiased}
  .container{max-width:1100px;margin:0 auto;padding:18px}
  header{position:sticky;top:0;background:rgba(3,10,30,0.6);backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,0.03);padding:10px 0;z-index:30}
  .hdr{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .badge{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#021024;padding:8px 12px;border-radius:999px;font-weight:800}
  h1{font-size:clamp(22px,3.6vw,34px);margin:6px 0}
  .subtitle{color:var(--muted);font-size:14px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:18px;border-radius:12px;margin-top:16px;box-shadow:0 10px 30px rgba(0,0,0,0.45)}
  .list{padding-left:18px}
  .list li{margin:8px 0}
  .muted{color:var(--muted)}
  .callout{background:linear-gradient(180deg,rgba(126,240,193,0.04),rgba(126,240,193,0.02));border:1px solid rgba(126,240,193,0.08);padding:10px;border-radius:8px}
  .warn{background:linear-gradient(180deg,rgba(255,123,123,0.04),rgba(255,123,123,0.02));border:1px solid rgba(255,123,123,0.06);padding:10px;border-radius:8px}
  .controls{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
  .btn{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);padding:10px 12px;border-radius:10px;color:var(--text);cursor:pointer;font-weight:700}
  .btn.primary{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#021024;border:none}
  pre{background:rgba(0,0,0,0.15);padding:12px;border-radius:8px;overflow:auto}
  footer{opacity:.9;padding:30px 0 60px;font-size:13px;color:var(--muted)}
  .section-sub{color:var(--muted);margin-top:6px;font-size:13px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}
  .quiz .q{margin:12px 0;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .result{margin-top:12px;padding:12px;border-radius:8px}
  .small{font-size:13px;color:var(--muted)}
  code{background:rgba(255,255,255,0.02);padding:2px 6px;border-radius:6px}
  /* TTS bar */
  .tts-bar{position:fixed;right:18px;bottom:18px;z-index:9999;background:rgba(1,6,12,0.85);color:#00ffcc;padding:10px 12px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.6);font-family:'Share Tech Mono',monospace;display:flex;gap:8px;align-items:center;backdrop-filter:blur(6px);min-width:320px}
  .tts-bar button{background:linear-gradient(45deg,#ff0080,#7928ca);border:none;color:#fff;padding:8px 10px;border-radius:8px;font-weight:700;cursor:pointer;min-width:44px}
  .tts-bar .small{padding:6px 8px;min-width:36px}
  .tts-bar select,.tts-bar input[type="range"]{background:rgba(255,255,255,0.06);color:#00ffcc;border:1px solid rgba(255,255,255,0.06);padding:6px;border-radius:8px;font-family:inherit}
  .tts-highlight{background:rgba(0,255,200,0.15);transition:background 0.2s;padding:0 2px;border-radius:3px}
  @media (max-width:600px){.tts-bar{left:50%;transform:translateX(-50%);right:auto;bottom:12px;min-width:88%}}
</style>
</head>
<body>
  <header>
    <div class="container hdr">
      <div style="display:flex;gap:12px;align-items:center">
        <span class="badge">Lesson 9</span>
        <div>
          <strong>DoS / DDoS & Session Hijacking — Expanded</strong>
          <div class="subtitle">Includes 10-question quiz and TTS controls</div>
        </div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" id="downloadNotes">📥 Download Notes</button>
        <button class="btn primary" id="copyMd">📋 Copy as Markdown</button>
      </div>
    </div>
  </header>

  <main class="container">
    <article class="card lesson-content">
      <h1>DoS / DDoS Attacks & Session Hijacking — Expanded</h1>
      <p class="section-sub">Concepts, detection, mitigation, incident playbook, safe labs, honeypots, and a 10-question quiz with explanations.</p>

      <section class="card">
        <h2>Table of Contents</h2>
        <ul class="list">
          <li>DDoS/DoS Attacks</li>
          <li>Signs of a DDoS/DoS Attack</li>
          <li>Types of DDoS Attacks & Detection Techniques</li>
          <li>What is a Session?</li>
          <li>Session Hijacking — techniques & types</li>
          <li>Session hijacking using XSS & sniffing</li>
          <li>Prevention & Incident Playbook</li>
          <li>Intrusion Detection Systems (IDS) & Types</li>
          <li>Honeypots — concepts and use</li>
          <li>Safe lab ideas and further reading</li>
        </ul>
      </section>

      <section class="card">
        <h2>DoS Attack — definition & context</h2>
        <p>
          A <strong>denial-of-service (DoS) attack</strong> aims to make a device, service, or network resource unavailable to legitimate users. Attackers accomplish this by exhausting resources (CPU, memory, bandwidth, file descriptors, connection tables), exploiting vulnerabilities, or otherwise preventing normal operation.
        </p>
        <p class="small muted">
          In practice, DoS attacks can be carried out for disruption, profit (ransom), political motives (hacktivism), or simply as a smokescreen for other malicious activity.
        </p>
      </section>

      <section class="card">
        <h2>Distributed Denial-of-Service (DDoS)</h2>
        <p>
          A <strong>DDoS</strong> attack follows the same goal as DoS but uses many distributed sources — often compromised or coerced devices (a botnet) — to magnify attack volume and complicate mitigation.
        </p>
        <p>
          Typical DDoS architecture: attacker &rarr; command-and-control (handlers) &rarr; zombies/bots &rarr; victim. Modern botnets may include IoT devices, cloud instances, or compromised servers.
        </p>
      </section>

      <section class="card">
        <h2>DDoS vs DoS — quick comparison</h2>
        <table style="width:100%;border-collapse:collapse">
          <thead><tr><th style="text-align:left">DoS</th><th style="text-align:left">DDoS</th></tr></thead>
          <tbody>
            <tr><td>Single attacking source</td><td>Multiple distributed sources</td></tr>
            <tr><td>Generally lower capacity</td><td>Often high capacity and harder to block</td></tr>
            <tr><td>Can be traced to one host (easier to block)</td><td>Requires coordination with ISPs/CDNs to defend</td></tr>
          </tbody>
        </table>
      </section>

      <section class="card">
        <h2>Signs of a DDoS/DoS Attack</h2>
        <ul class="list">
          <li>Slow network or application performance.</li>
          <li>Partial or full unavailability of a website/service.</li>
          <li>Spikes in traffic volume (packets/sec or bits/sec) without corresponding business activity.</li>
          <li>Increased server errors (HTTP 500/503) and resource exhaustion.</li>
          <li>Unusual traffic patterns or many connections from a single IP range or many source IPs with similar signatures.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Why do DDoS attacks happen?</h2>
        <ul class="list">
          <li><strong>Ransom:</strong> attackers demand payment to stop attacks.</li>
          <li><strong>Hacktivism:</strong> political or social activism.</li>
          <li><strong>Competition:</strong> sabotage between businesses.</li>
          <li><strong>Distraction:</strong> use DoS to distract defenders while other attacks occur.</li>
        </ul>
        <p class="small muted">Historically major incidents (2000, 2017) show how disruptive DDoS can be to infrastructure and services.</p>
      </section>

      <section class="card">
        <h2>Types of DDoS Attacks</h2>
        <p>Attacks are commonly grouped by technique and the layer they target:</p>
        <ul class="list">
          <li><strong>Volumetric attacks</strong> — saturate bandwidth (UDP flood, DNS/NTP amplification).</li>
          <li><strong>Protocol attacks</strong> — exhaust protocol state (SYN flood, fragment attacks).</li>
          <li><strong>Application-layer attacks</strong> — target application logic and resources (HTTP flood, Slowloris).</li>
        </ul>
        <p class="small muted">Zero-day DDoS techniques may combine methods or exploit unpatched software for greater effect.</p>
      </section>

      <section class="card">
        <h3>Volumetric attack examples</h3>
        <ul class="list">
          <li><strong>UDP flood</strong> — forged packets to random/targeted ports; victims respond or are overloaded.</li>
          <li><strong>Amplification (DNS/NTP)</strong> — small spoofed request causes large response from misconfigured public servers, amplifying traffic to victim.</li>
        </ul>
      </section>

      <section class="card">
        <h3>Protocol attack examples</h3>
        <ul class="list">
          <li><strong>SYN flood</strong> — incomplete TCP handshakes leave server connection state filled.</li>
          <li><strong>Ping of Death / ICMP floods</strong> — oversized or numerous ICMP messages.</li>
        </ul>
      </section>

      <section class="card">
        <h3>Application-layer attacks</h3>
        <ul class="list">
          <li><strong>HTTP flood</strong> — many seemingly-legitimate HTTP requests (GET/POST), often generated by botnets, overwhelming app servers.</li>
          <li><strong>Slowloris</strong> — many partial HTTP requests kept open to exhaust server resources.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Detection Techniques</h2>
        <ul class="list">
          <li><strong>Traffic monitoring:</strong> use NetFlow/IPFIX, packet captures and edge logs to detect spikes and anomalies.</li>
          <li><strong>Behavioral analysis:</strong> baseline normal traffic patterns then detect deviations (rate, geo-distribution, protocol mix).</li>
          <li><strong>Signature-based detection:</strong> known attack patterns identified via IDS/IPS rules (e.g., Suricata, Snort).</li>
          <li><strong>Rate limiting & challenge-response:</strong> throttle excessive requests, present CAPTCHAs where appropriate.</li>
          <li><strong>Network flow analysis:</strong> aggregate and analyze flows for volumetric anomalies.</li>
          <li><strong>Anomaly detection (ML-based):</strong> systems that learn normal operation and alert on unusual signals.</li>
        </ul>
      </section>

      <section class="card">
        <h2>What is a Session?</h2>
        <p>
          A web session is a logical, continuous interaction between a user and an application that persists across multiple HTTP requests. Sessions are typically implemented using session tokens (cookies, JWTs, etc.) that the server issues to authenticated users to avoid re-authentication for every request.
        </p>
        <p class="small muted">Since HTTP is stateless, session tokens are the mechanism that provides continuity of identity and permissions.</p>
      </section>

      <section class="card">
        <h2>Session Hijacking — overview</h2>
        <p>
          <strong>Session hijacking</strong> occurs when an attacker obtains or predicts a valid session token and uses it to impersonate a legitimate user. The attacker then performs actions with the same privileges as that user (read data, perform transactions, change settings).
        </p>
      </section>

      <section class="card">
        <h3>How session hijacking works — primary techniques</h3>
        <ul class="list">
          <li><strong>Steal:</strong> capture session IDs via XSS, packet sniffing (on insecure networks), or malware.</li>
          <li><strong>Predict:</strong> weak or predictable token generation allows brute-force or calculation-based hijack.</li>
          <li><strong>Fixate:</strong> attacker sets a session ID for the victim (session fixation) then waits for the victim to authenticate.</li>
          <li><strong>Man-in-the-middle:</strong> intercepting traffic (e.g., through ARP spoofing) to capture tokens or credentials.</li>
        </ul>
      </section>

      <section class="card">
        <h3>Types of session hijacking attacks</h3>
        <ul class="list">
          <li>Cross-site scripting (XSS) theft of cookies</li>
          <li>Session sidejacking (sniffing session cookies on insecure networks)</li>
          <li>Session fixation</li>
          <li>Man-in-the-browser attacks (malicious browser extensions or malware)</li>
        </ul>
      </section>

      <section class="card">
        <h3>Session hijacking using XSS (flow)</h3>
        <ol class="list">
          <li>Attacker finds XSS vulnerability and injects script into a page.</li>
          <li>Victim visits the vulnerable page and executes injected script in their browser.</li>
          <li>The script reads document.cookie (unless HttpOnly) or sends the token to attacker.</li>
          <li>Attacker uses the stolen token to impersonate the user.</li>
        </ol>
        <p class="small muted">Mitigation: sanitize inputs, use Content Security Policy, and store tokens in HttpOnly cookies rather than accessible storage.</p>
      </section>

      <section class="card">
        <h3>Session hijacking using packet sniffing</h3>
        <p>
          On insecure networks (open Wi-Fi), an attacker can capture unencrypted HTTP traffic and extract session cookies or tokens. Using HTTPS prevents easy interception because the session is encrypted in transit.
        </p>
      </section>

      <section class="card">
        <h2>How to prevent session hijacking</h2>
        <ul class="list">
          <li><strong>Enforce TLS everywhere:</strong> use HTTPS on all pages (including non-sensitive ones) and HSTS to prevent protocol downgrade.</li>
          <li><strong>HttpOnly cookie flag:</strong> prevents JavaScript from reading cookie values.</li>
          <li><strong>Secure cookie flag:</strong> ensures cookies are only sent over TLS.</li>
          <li><strong>SameSite cookie flag:</strong> helps reduce CSRF and cross-site leakage.</li>
          <li><strong>Short lifetimes & rotation:</strong> regenerate session IDs after privilege changes (login) and use short expirations for tokens.</li>
          <li><strong>Use strong random token generators:</strong> ensure session IDs are cryptographically strong and unpredictable.</li>
          <li><strong>MFA & reauthentication:</strong> require step-up authentication for sensitive operations.</li>
          <li><strong>IP / user-agent binding and anomaly detection:</strong> monitor for unusual session behavior and revalidate when anomalies occur.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Incident response playbook (high-level)</h2>
        <ol class="list">
          <li><strong>Detect:</strong> monitor anomalies, WAF triggers, IDS alerts.</li>
          <li><strong>Contain:</strong> redirect or rate-limit traffic, apply access controls, bring in CDN scrubbing.</li>
          <li><strong>Eradicate:</strong> remove malicious artifacts, patch exploited vulnerabilities.</li>
          <li><strong>Recover:</strong> restore services, validate integrity, rotate credentials and tokens.</li>
          <li><strong>Post-incident:</strong> review logs, strengthen defenses, update playbooks.</li>
        </ol>
      </section>

      <section class="card">
        <h2>Intrusion Detection Systems (IDS)</h2>
        <p>
          IDS monitor network or host activity for malicious behavior and alert administrators. They do not (usually) block traffic themselves — that is Intrusion Prevention System (IPS) territory — but integration with blocking systems is common.
        </p>
        <h3>Types of IDS:</h3>
        <ul class="list">
          <li><strong>Network-based (NIDS):</strong> monitor packet streams on networks (examples: Zeek, Suricata).</li>
          <li><strong>Host-based (HIDS):</strong> monitor activity on servers/endpoints (file integrity, logs).</li>
        </ul>
        <p class="small muted">IDS effectiveness depends on good baseline data, well-tuned rules, and integration with SIEM for correlation & context.</p>
      </section>

      <section class="card">
        <h2>Honeypots — concept & uses</h2>
        <p>
          A <strong>honeypot</strong> is a deliberately exposed resource designed to attract attackers and monitor their behavior. Honeypots can be <em>low-interaction</em> (simulate services) or <em>high-interaction</em> (real systems instrumented for monitoring).
        </p>
        <ul class="list">
          <li><strong>Detection:</strong> early signals of active attacks.</li>
          <li><strong>Research:</strong> learn new attacker TTPs (tools, techniques, procedures).</li>
          <li><strong>Diversion:</strong> keep attackers busy away from production systems.</li>
        </ul>
        <p class="small muted">Important: isolate honeypots from production networks to avoid them being pivot points for attackers.</p>
      </section>

      <section class="card">
        <h2>Safe lab ideas</h2>
        <ul class="list">
          <li>Mirror a small lab network and generate synthetic traffic to learn baseline and anomalies.</li>
          <li>Deploy Zeek + Suricata in the lab and simulate DoS conditions to see alerting behavior (do NOT run real attacks on production or public networks).</li>
          <li>Test session management practices: build a small web app and experiment with cookie flags, token rotation, and session fixation tests in a controlled environment.</li>
          <li>Set up a low-interaction honeypot and analyze the logs to see reconnaissance and automated attack patterns.</li>
        </ul>
      </section>

      <section class="card">
        <h2>Tools & references</h2>
        <ul class="list">
          <li>Zeek, Suricata, Wireshark — network monitoring and analysis</li>
          <li>Cloudflare, Akamai, AWS Shield — DDoS mitigation services (commercial)</li>
          <li>OWASP — Session Management Cheat Sheet</li>
          <li>NIST SP 800-series — incident response and best practices</li>
        </ul>
      </section>

      <!-- Quiz: 10 questions -->
      <section class="card quiz" aria-labelledby="quiz">
        <h2 id="quiz">10-question Quiz (self-check) — Defensive focus</h2>

        <div class="q">
          <strong>1.</strong> Which mitigation is most effective for large volumetric DDoS attacks?<br>
          <label><input type="radio" name="q1" value="a"> Increasing application logging</label><br>
          <label><input type="radio" name="q1" value="b"> Engaging a CDN/scrubbing provider</label><br>
          <label><input type="radio" name="q1" value="c"> Disabling TLS</label>
        </div>

        <div class="q">
          <strong>2.</strong> Which cookie flag helps prevent JavaScript access to a session cookie?<br>
          <label><input type="radio" name="q2" value="a"> Secure</label><br>
          <label><input type="radio" name="q2" value="b"> HttpOnly</label><br>
          <label><input type="radio" name="q2" value="c"> Expires</label>
        </div>

        <div class="q">
          <strong>3.</strong> A SYN flood is best described as which sort of attack?<br>
          <label><input type="radio" name="q3" value="a"> Volumetric</label><br>
          <label><input type="radio" name="q3" value="b"> Protocol (state-exhaustion)</label><br>
          <label><input type="radio" name="q3" value="c"> Application layer</label>
        </div>

        <div class="q">
          <strong>4.</strong> Which of the following helps prevent session fixation?<br>
          <label><input type="radio" name="q4" value="a"> Regenerate session ID after login</label><br>
          <label><input type="radio" name="q4" value="b"> Longer session lifetime</label><br>
          <label><input type="radio" name="q4" value="c"> Store session in localStorage</label>
        </div>

        <div class="q">
          <strong>5.</strong> Which detection technique uses historical baselines and ML to spot anomalies?<br>
          <label><input type="radio" name="q5" value="a"> Signature-based detection</label><br>
          <label><input type="radio" name="q5" value="b"> Behavioral/Anomaly detection</label><br>
          <label><input type="radio" name="q5" value="c"> Manual packet captures only</label>
        </div>

        <div class="q">
          <strong>6.</strong> What does a honeypot primarily provide?<br>
          <label><input type="radio" name="q6" value="a"> Production traffic acceleration</label><br>
          <label><input type="radio" name="q6" value="b"> Decoy to observe attacker behavior and early warning</label><br>
          <label><input type="radio" name="q6" value="c"> Automatic removal of malicious IPs from the internet</label>
        </div>

        <div class="q">
          <strong>7.</strong> Which is a safe way to protect session tokens from network interception?<br>
          <label><input type="radio" name="q7" value="a"> Always use HTTPS/TLS everywhere</label><br>
          <label><input type="radio" name="q7" value="b"> Send tokens over HTTP but obfuscate with JS</label><br>
          <label><input type="radio" name="q7" value="c"> Publish session tokens in CSS files</label>
        </div>

        <div class="q">
          <strong>8.</strong> An application shows many long-running open HTTP connections from the same IP, slowly sending headers. Which attack does this resemble?<br>
          <label><input type="radio" name="q8" value="a"> Slowloris / Slow POST (application-layer)</label><br>
          <label><input type="radio" name="q8" value="b"> DNS amplification (volumetric)</label><br>
          <label><input type="radio" name="q8" value="c"> SYN flood (protocol)</label>
        </div>

        <div class="q">
          <strong>9.</strong> Which response is an appropriate immediate step when your monitoring shows a DDoS impacting availability?<br>
          <label><input type="radio" name="q9" value="a"> Activate the incident playbook and contact your CDN/ISP</label><br>
          <label><input type="radio" name="q9" value="b"> Immediately rotate all database passwords</label><br>
          <label><input type="radio" name="q9" value="c"> Publish credentials for employees to share</label>
        </div>

        <div class="q">
          <strong>10.</strong> Which of these best reduces the risk from XSS-based session hijacking?<br>
          <label><input type="radio" name="q10" value="a"> Storing session tokens in HttpOnly cookies and sanitizing inputs</label><br>
          <label><input type="radio" name="q10" value="b"> Allowing inline scripts from any origin</label><br>
          <label><input type="radio" name="q10" value="c"> Using predictable numeric session IDs</label>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:10px">
          <button class="btn primary" id="grade">Grade Quiz</button>
          <button class="btn" id="showAnswers">Show Answers & Explanations</button>
        </div>

        <div id="result" class="result"></div>
      </section>

      <section class="card">
        <h2>Further reading & next steps</h2>
        <ul class="list">
          <li>OWASP — Session Management Cheat Sheet (practical guidance)</li>
          <li>Cloudflare, Akamai, AWS Shield — vendor docs on DDoS mitigation</li>
          <li>Zeek (Bro) & Suricata — network monitoring & IDS tools</li>
          <li>NIST SP 800-61 (Computer Security Incident Handling Guide)</li>
        </ul>
      </section>

    </article>

    <footer class="container">
      <p>© Defensive Training — DoS/DDoS & Session Hijacking</p>
    </footer>
  </main>

  <!-- TTS bar -->
  <div id="ttsBar" class="tts-bar" aria-hidden="false" role="region" aria-label="Text to Speech Controls">
    <button id="ttsPlay" title="Play">▶</button>
    <button id="ttsPause" title="Pause">⏸</button>
    <button id="ttsStop" title="Stop">⏹</button>
    <span class="small">Voice</span>
    <select id="ttsVoices" aria-label="Select voice"></select>
    <span class="small">Rate</span>
    <input id="ttsRate" type="range" min="0.6" max="2" step="0.1" value="1" />
    <span class="small">Pitch</span>
    <input id="ttsPitch" type="range" min="0.6" max="2" step="0.1" value="1" />
    <button id="ttsToggleAuto" class="small" title="Auto-read on load">A</button>
  </div>

<script>
  // Download/Copy handlers
  document.getElementById('downloadNotes').addEventListener('click', () => {
    const nodes = document.querySelectorAll('main article h1, main article h2, main article h3, main article p, main article li, main article pre');
    const lines = [];
    nodes.forEach(n => {
      const text = n.innerText.trim();
      if (text) lines.push(text);
    });
    const blob = new Blob([lines.join('\n\n')], {type:'text/plain'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a');
    a.href = url; a.download = 'Lesson9_DDoS_SessionHijack_Notes.txt'; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 500);
  });

  document.getElementById('copyMd').addEventListener('click', async () => {
    const nodes = document.querySelectorAll('main article h1, main article h2, main article h3, main article p, main article li, main article pre');
    let md = '';
    nodes.forEach(n => {
      const tag = n.tagName.toLowerCase();
      const txt = n.innerText.trim();
      if (!txt) return;
      if (tag === 'h1') md += `# ${txt}\n\n`;
      else if (tag === 'h2') md += `## ${txt}\n\n`;
      else if (tag === 'h3') md += `### ${txt}\n\n`;
      else if (tag === 'pre') md += '```\n' + txt + '\n```\n\n';
      else if (tag === 'li') md += `- ${txt}\n`;
      else md += `${txt}\n\n`;
    });
    try { await navigator.clipboard.writeText(md); alert('Copied notes as Markdown.'); }
    catch(e){ alert('Could not copy to clipboard.'); }
  });

  // Quiz logic and explanations
  const answers = {
    q1: {a:false, b:true,  c:false, explain:"Large volumetric attacks are best mitigated by CDNs/scrubbing providers that absorb or filter traffic before it reaches your origin."},
    q2: {a:false, b:true,  c:false, explain:"HttpOnly prevents JavaScript from reading cookies; 'Secure' ensures cookies are sent only over TLS."},
    q3: {a:false, b:true,  c:false, explain:"SYN floods exploit TCP connection state, exhausting server resources — a protocol/state-exhaustion attack."},
    q4: {a:true,  b:false, c:false, explain:"Regenerating the session ID after authentication prevents session fixation attacks."},
    q5: {a:false, b:true,  c:false, explain:"Behavioral/anomaly detection uses baselines and ML to spot traffic deviating from normal patterns."},
    q6: {a:false, b:true,  c:false, explain:"Honeypots are decoys designed to observe attacker behavior and provide early warning; they do not accelerate real production traffic."},
    q7: {a:true,  b:false, c:false, explain:"Always using HTTPS/TLS ensures session tokens are encrypted in transit and not easily intercepted."},
    q8: {a:true,  b:false, c:false, explain:"Long-lived, incomplete HTTP connections are typical of Slowloris-style application-layer attacks."},
    q9: {a:true,  b:false, c:false, explain:"Activating the incident playbook and contacting CDN/ISP are appropriate immediate steps to mitigate impact and coordinate filtering."},
    q10:{a:true,  b:false, c:false, explain:"HttpOnly cookies and proper input sanitization greatly reduce the risk of XSS-based token theft."}
  };

  document.getElementById('grade').addEventListener('click', () => {
    let score = 0;
    const explanations = [];
    for (let i=1;i<=10;i++){
      const name = 'q'+i;
      const sel = document.querySelector(`input[name="${name}"]:checked`);
      const key = name;
      const correct = Object.keys(answers[key]).find(k=>k!=='explain' && answers[key][k]===true);
      const isCorrect = sel && answers[key][sel.value]===true;
      if (isCorrect) score++;
      const user = sel ? sel.value : '(no answer)';
      explanations.push(`<strong>Q${i}:</strong> Your answer: ${user}. ${isCorrect?'<span style="color:var(--ok)">Correct</span>':'<span style="color:var(--danger)">Incorrect</span>' }<br><em>Explanation:</em> ${answers[key].explain}`);
    }
    const out = document.getElementById('result');
    out.innerHTML = `<strong>Score:</strong> ${score} / 10<br><div style="margin-top:8px">${explanations.join('<hr>')}</div>`;
    out.scrollIntoView({behavior:'smooth', block:'center'});
  });

  document.getElementById('showAnswers').addEventListener('click', () => {
    const out = document.getElementById('result');
    const lines = [];
    for (let i=1;i<=10;i++){
      const key = 'q'+i;
      const correct = Object.keys(answers[key]).find(k=>k!=='explain' && answers[key][k]===true);
      lines.push(`<strong>Q${i} correct answer:</strong> ${correct.toUpperCase()}. <em>${answers[key].explain}</em>`);
    }
    out.innerHTML = lines.join('<hr>');
    out.scrollIntoView({behavior:'smooth', block:'center'});
  });

  // TTS module (Web Speech API)
  (function(){
    if (!('speechSynthesis' in window)) {
      const bar = document.getElementById('ttsBar'); if (bar) bar.style.display='none';
      return;
    }
    const playBtn = document.getElementById('ttsPlay');
    const pauseBtn = document.getElementById('ttsPause');
    const stopBtn = document.getElementById('ttsStop');
    const voicesSelect = document.getElementById('ttsVoices');
    const rateInput = document.getElementById('ttsRate');
    const pitchInput = document.getElementById('ttsPitch');
    const autoBtn = document.getElementById('ttsToggleAuto');

    let voices = [];
    function populateVoices(){
      voices = speechSynthesis.getVoices();
      voicesSelect.innerHTML='';
      voices.forEach(v=>{
        const opt = document.createElement('option'); opt.value = v.voiceURI;
        opt.textContent = `${v.name} (${v.lang})${v.default?' — default':''}`;
        voicesSelect.appendChild(opt);
      });
      // try to restore saved voice
      const saved = localStorage.getItem('lesson9.voice');
      if (saved) voicesSelect.value = saved;
    }

    populateVoices();
    if (speechSynthesis.onvoiceschanged!==undefined) speechSynthesis.onvoiceschanged = populateVoices;

    function getTextForTTS(){
      // choose main lesson text (headers + paragraphs)
      const nodes = document.querySelectorAll('.lesson-content h1, .lesson-content h2, .lesson-content h3, .lesson-content p');
      return Array.from(nodes).map(n=>n.innerText.trim()).filter(Boolean).join('.\n');
    }

    function speakAll(){
      cancel();
      const raw = getTextForTTS();
      const sentences = raw.split(/(?<=[.?!])\s+/);
      let idx = 0;
      function speakNext(){
        if (idx >= sentences.length) return;
        const s = sentences[idx++];
        const u = new SpeechSynthesisUtterance(s);
        // pick voice
        const selURI = voicesSelect.value;
        const sel = voices.find(v=>v.voiceURI===selURI) || voices.find(v=>v.default) || voices[0];
        if (sel) u.voice = sel;
        u.rate = parseFloat(rateInput.value);
        u.pitch = parseFloat(pitchInput.value);
        u.onstart = ()=> highlightSentence(s);
        u.onend = ()=> {
          removeHighlights();
          setTimeout(()=> speakNext(), 80);
        };
        speechSynthesis.speak(u);
      }
      speakNext();
    }

    function cancel(){ if (speechSynthesis.speaking || speechSynthesis.pending) speechSynthesis.cancel(); }
    function pause(){ if (speechSynthesis.speaking) speechSynthesis.pause(); }
    function resume(){ if (speechSynthesis.paused) speechSynthesis.resume(); }

    function highlightSentence(sentence){
      removeHighlights();
      const lesson = document.querySelector('.lesson-content');
      if (!lesson) return;
      const safe = sentence.replace(/[.*+?^${}()|[\]\\]/g,'\\$&').trim();
      if (!safe) return;
      const regex = new RegExp(safe);
      lesson.innerHTML = lesson.innerHTML.replace(regex, `<span class="tts-highlight">${sentence}</span>`);
    }
    function removeHighlights(){
      const lesson = document.querySelector('.lesson-content');
      if (!lesson) return;
      const els = lesson.querySelectorAll('.tts-highlight');
      els.forEach(el => { el.outerHTML = el.textContent; });
    }

    playBtn.addEventListener('click', ()=> {
      if (speechSynthesis.paused) return resume();
      if (speechSynthesis.speaking) return;
      speakAll();
      localStorage.setItem('lesson9.voice', voicesSelect.value || '');
      localStorage.setItem('lesson9.rate', rateInput.value);
      localStorage.setItem('lesson9.pitch', pitchInput.value);
    });
    pauseBtn.addEventListener('click', ()=> {
      if (speechSynthesis.speaking) pause();
      else if (speechSynthesis.paused) resume();
    });
    stopBtn.addEventListener('click', ()=> { cancel(); removeHighlights(); });

    voicesSelect.addEventListener('change', ()=> localStorage.setItem('lesson9.voice', voicesSelect.value));
    rateInput.addEventListener('change', ()=> localStorage.setItem('lesson9.rate', rateInput.value));
    pitchInput.addEventListener('change', ()=> localStorage.setItem('lesson9.pitch', pitchInput.value));

    // auto toggle
    const savedAuto = localStorage.getItem('lesson9.auto') === 'true';
    autoBtn.style.opacity = savedAuto ? '1' : '0.6';
    autoBtn.addEventListener('click', ()=> {
      const cur = localStorage.getItem('lesson9.auto') === 'true';
      localStorage.setItem('lesson9.auto', (!cur).toString());
      autoBtn.style.opacity = (!cur) ? '1' : '0.6';
    });

    // apply saved settings when ready
    const applySaved = () => {
      const sv = localStorage.getItem('lesson9.voice');
      if (sv && voices.find(v=>v.voiceURI===sv)) voicesSelect.value = sv;
      const sr = localStorage.getItem('lesson9.rate') || rateInput.value;
      const sp = localStorage.getItem('lesson9.pitch') || pitchInput.value;
      rateInput.value = sr; pitchInput.value = sp;
      if (localStorage.getItem('lesson9.auto') === 'true') {
        try { speakAll(); } catch(e) { console.warn('Auto TTS blocked'); }
      }
    };

    // voices may not be loaded immediately
    let tries = 0;
    const iv = setInterval(()=> {
      if (speechSynthesis.getVoices().length) {
        populateVoices(); applySaved(); clearInterval(iv);
      } else if (++tries > 30) { applySaved(); clearInterval(iv); }
    }, 200);
  })();
</script>
</body>
</html>
